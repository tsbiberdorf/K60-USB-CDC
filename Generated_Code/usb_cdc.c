/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : usb_cdc.c
**     Project     : ProcessorExpert
**     Processor   : MK60DN512VLQ10
**     Component   : USB_CDC_CLASS
**     Version     : Component 01.000, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2013-12-09, 14:17, # CodeGen: 4
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         USB_Class_CDC_Init      - uint_8 usb_cdc_USB_Class_CDC_Init(void* controller_ID, void*...
**         USB_Class_CDC_DeInit    - uint_8 usb_cdc_USB_Class_CDC_DeInit(void* controller_ID);
**         USB_Class_CDC_Send_Data - uint_8 usb_cdc_USB_Class_CDC_Send_Data(void* controller_ID, void* ep_num,...
**
**     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
**     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/
/*!
** @file usb_cdc.c
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup usb_cdc_module usb_cdc module documentation
**  @{
*/         

/* MODULE usb_cdc. */

#include "usb_cdc.h"

/* CDC Class Callback Function Pointer */
static USB_CLASS_CALLBACK g_cdc_class_callback = NULL;

/* CDC Class Vendor Callback Function Pointer */
static USB_REQ_FUNC g_vendor_req_callback = NULL;

/* CDC endpoint info array */
static USB_CLASS_CDC_ENDPOINT g_cdc_ep[CDC_DESC_ENDPOINT_COUNT];
/* Internal method prototypes */
static void USB_Class_CDC_Service_Cic_Notify(PTR_USB_DEV_EVENT_STRUCT event);
static void USB_Class_CDC_Service_Dic_Bulk_In(PTR_USB_DEV_EVENT_STRUCT event);
static void USB_Class_CDC_Service_Dic_Bulk_Out(PTR_USB_DEV_EVENT_STRUCT event);
static uint_8 USB_Other_Requests(uint_8 controller_ID, USB_SETUP_STRUCT *setup_packet, uint_8_ptr *data, USB_PACKET_SIZE *size);
static void USB_Class_CDC_Event(uint_8 controller_ID, uint_8 event, void* val);


/*
** ===================================================================
**     Method      :  USB_Class_CDC_Service_Cic_Notify (component USB_CDC_CLASS)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Class_CDC_Service_Cic_Notify(PTR_USB_DEV_EVENT_STRUCT event)
{

    if(g_cdc_class_callback != NULL)
    {
        uint_8 event_type = USB_APP_SEND_COMPLETE;

        if(event->errors != 0)
        {
            event_type = USB_APP_ERROR;
        }
        g_cdc_class_callback(event->controller_ID, event_type,
        (uint_8*)(&(event->errors)));
    }

}
/*
** ===================================================================
**     Method      :  USB_Class_CDC_Service_Dic_Bulk_In (component USB_CDC_CLASS)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Class_CDC_Service_Dic_Bulk_In(PTR_USB_DEV_EVENT_STRUCT event)
{
    APP_DATA_STRUCT bulk_in_recv;

    if(g_cdc_class_callback != NULL)
    {
        if(event->errors != 0)
        {
            g_cdc_class_callback(event->controller_ID, USB_APP_ERROR,
                (uint_8*)(&(event->errors)));
        }
        else
        {
            g_cdc_class_callback(event->controller_ID, USB_APP_SEND_COMPLETE,
                (void*)&bulk_in_recv);
        }
    }
}

/*
** ===================================================================
**     Method      :  USB_Class_CDC_Service_Dic_Bulk_Out (component USB_CDC_CLASS)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Class_CDC_Service_Dic_Bulk_Out(PTR_USB_DEV_EVENT_STRUCT event)
{
   APP_DATA_STRUCT bulk_out_recv;

    bulk_out_recv.data_ptr = event->buffer_ptr;
    bulk_out_recv.data_size = event->len;

    if(g_cdc_class_callback != NULL)
    {
        if(event->errors != 0)
        {
            g_cdc_class_callback(event->controller_ID, USB_APP_ERROR,
                (uint_8*)(&(event->errors)));
        }
        else
        {
            g_cdc_class_callback(event->controller_ID, USB_APP_DATA_RECEIVED,
                (void*)&bulk_out_recv);
        }
    }
}
/*
** ===================================================================
**     Method      :  USB_Class_CDC_Event (component USB_CDC_CLASS)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Class_CDC_Event(uint_8 controller_ID, uint_8 event, void* val)
{

    uint_8 index;
    USB_ENDPOINTS *usb_ep_data = (USB_ENDPOINTS *)
        USB_Desc_Get_Endpoints(controller_ID);

    if(event == USB_APP_ENUM_COMPLETE)
    {
                uint_8 count;
                count = usb_ep_data->count;
                /* deinitialize all endpoints in case they were initialized */
                while(count > 0)
                {
                        USB_EP_STRUCT_PTR ep_struct_ptr=
                                (USB_EP_STRUCT_PTR) (&usb_ep_data->ep[count - 1]);
                        (void)_usb_device_deinit_endpoint(&controller_ID,
                                ep_struct_ptr->ep_num, ep_struct_ptr->direction);
                         count--;
                }

        /* intialize all non control endpoints */
        while(count < usb_ep_data->count)
        {
            USB_EP_STRUCT_PTR ep_struct=
                (USB_EP_STRUCT_PTR) (&usb_ep_data->ep[count]);

            (void)_usb_device_init_endpoint(&controller_ID, ep_struct->ep_num,
                            ep_struct->size, ep_struct->direction, ep_struct->type, FALSE);

            /* register callback service for Non Control EndPoints */
            switch(ep_struct->type)
            {
                case USB_INTERRUPT_PIPE :
                    (void)_usb_device_register_service(controller_ID,
                        (uint_8)(USB_SERVICE_EP0+ep_struct->ep_num),
                        USB_Class_CDC_Service_Cic_Notify);
                    break;
                case USB_BULK_PIPE :
                    if(ep_struct->direction == USB_RECV)
                    {
                        (void)_usb_device_register_service(controller_ID,
                            (uint_8)(USB_SERVICE_EP0+ep_struct->ep_num),
                            USB_Class_CDC_Service_Dic_Bulk_Out);
                    }
                    else
                    {
                        (void)_usb_device_register_service(controller_ID,
                            (uint_8)(USB_SERVICE_EP0+ep_struct->ep_num),
                            USB_Class_CDC_Service_Dic_Bulk_In);
                    }
                    break;
                default:
                    break;
            }
            /* set the EndPoint Status as Idle in the device layer */
            (void)_usb_device_set_status(&controller_ID,
                (uint_8)(USB_STATUS_ENDPOINT | ep_struct->ep_num |
                (ep_struct->direction << USB_COMPONENT_DIRECTION_SHIFT)),
                (uint_8)USB_STATUS_IDLE);
            count++;
        }
    }
    else if(event == USB_APP_BUS_RESET)
    {
    }
    if(g_cdc_class_callback != NULL)
    {
        g_cdc_class_callback(controller_ID, event, val);
    }
}

/*
** ===================================================================
**     Method      :  USB_Other_Requests (component USB_CDC_CLASS)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Other_Requests(uint_8 controller_ID, USB_SETUP_STRUCT *setup_packet, uint_8_ptr *data, USB_PACKET_SIZE *size)
{

    uint_8 status = USBERR_INVALID_REQ_TYPE;
    if((setup_packet->request_type & USB_REQUEST_CLASS_MASK) ==
        USB_REQUEST_CLASS_CLASS)
    {
        /* class request so handle it here */
        status=USB_OK;

        /* call for class/subclass specific requests */
        switch(setup_packet->request)
        {
            case SEND_ENCAPSULATED_COMMAND :
                /* Add code to transfer Request and Acknowledgement */
                *size=0;
                break;
            case GET_ENCAPSULATED_RESPONSE :
                /*
                   Add code for handling Transfer Response/Requests and
                   Notification
                */
                *size=0;
                break;
            case SET_COMM_FEATURE :
                status = USB_Class_CDC_PSTN_Set_Comm_Feature(controller_ID,
                    setup_packet, data, size);
                break;
            case GET_COMM_FEATURE :
                status = USB_Class_CDC_PSTN_Get_Comm_Feature(controller_ID,
                    setup_packet, data, size);
                break;
            case CLEAR_COMM_FEATURE : /* Verify this implementation */
                *size = COMM_FEATURE_DATA_SIZE;
                **data = 0x00; *(++(*data)) = 0x00;/* clear both feature bytes */
                status = USB_Class_CDC_PSTN_Set_Comm_Feature(controller_ID,
                    setup_packet, data, size);
              break;
            case GET_LINE_CODING :
                status = USB_Class_CDC_PSTN_Get_Line_Coding(controller_ID,
                    setup_packet, data, size);
                break;
            case SET_LINE_CODING :
                status = USB_Class_CDC_PSTN_Set_Line_Coding(controller_ID,
                    setup_packet, data, size);
                break;
            case SET_CONTROL_LINE_STATE :
                status = USB_Class_CDC_PSTN_Set_Ctrl_Line_State(controller_ID,
                    setup_packet, data, size);
                break;
            case SEND_BREAK :
                status = USB_Class_CDC_PSTN_Send_Break(controller_ID,
                    setup_packet, data, size);
                break;
            default:
                *size=0;
                break;
        }
    }
    else if((setup_packet->request_type & USB_REQUEST_CLASS_MASK) ==
        USB_REQUEST_CLASS_VENDOR)
    {
        /* vendor specific request  */
        if(g_vendor_req_callback != NULL)
        {
            status = g_vendor_req_callback(controller_ID, setup_packet, data,
            size);
        }
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Class_CDC_Init (component USB_CDC_CLASS)
**     Description :
**         The function initializes the Device and Controller layer
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - [IN] Controller ID
**         cdc_class_callback - [IN] CDC
**                           Class Callback
**         vendor_req_callback - [IN]
**                           Vendor Request Callback
**         pstn_callback   - [IN] PSTN Callback
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_CDC_Init(uint_8 controller_ID, USB_CLASS_CALLBACK cdc_class_callback, USB_REQ_FUNC vendor_req_callback, USB_CLASS_CALLBACK pstn_callback)
{

    uint_8 index;
    USB_ENDPOINTS *usb_ep_data =
        (USB_ENDPOINTS *)USB_Desc_Get_Endpoints(controller_ID);
    /* Initialize the device layer*/
    uint_8 status = _usb_device_init(controller_ID, NULL,
        (uint_8)(usb_ep_data->count+1));
    /* +1 is for Control Endpoint */

    if(status == USB_OK)
    {
        /* Initialize the generic class functions */
        status = USB_Class_Init(controller_ID,USB_Class_CDC_Event,
            USB_Other_Requests);
#if PSTN_SUBCLASS_NOTIF_SUPPORT
        /* Initialize the pstn subclass functions */
        status = USB_Class_CDC_Pstn_Init(controller_ID,pstn_callback);
#endif
        if(status == USB_OK)
        {
           /* save the callback pointer */
           g_cdc_class_callback = cdc_class_callback;

           /* save the callback pointer */
           g_vendor_req_callback = vendor_req_callback;
        }
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Class_CDC_DeInit (component USB_CDC_CLASS)
**     Description :
**         The function de-initializes the Device and Controller layer
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - [IN] Controller ID
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_CDC_DeInit(uint_8 controller_ID)
{
    uint_8 status;

    /* save the callback pointer */
    g_cdc_class_callback = NULL;

    /* free the vendor request callback pointer */
    g_vendor_req_callback = NULL;

    /* call common class deinit function */
    status = USB_Class_DeInit(controller_ID);

    if(status == USB_OK)
    /* Call device deinit function */
            status = _usb_device_deinit();
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Class_CDC_Send_Data (component USB_CDC_CLASS)
**     Description :
**         This function is used to send data from CDC Class over send
**         endpoints
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - [IN] Controller ID
**         ep_num          - [IN] Endpoint Number
**         app_buff        - Pointer to Application Buffer
**         size            - Size of Application Buffer
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_CDC_Send_Data(uint_8 controller_ID, uint_8 ep_num, uint_8_ptr app_buff, USB_PACKET_SIZE size)
{
    uint_8 status = USB_OK;
            status = USB_Class_Send_Data(controller_ID, ep_num, app_buff,size);
    return status;
}

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.2 [05.07]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
